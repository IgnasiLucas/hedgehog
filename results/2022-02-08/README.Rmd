---
title: "Check the results from BGC"
author: "J. Ignacio Lucas Lledó"
date: "8/2/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Genomic clines

@Gompert2011 developed a hierarchical model of how ancestry in a locus vary
across individuals as a function of the genome-wide fraction of the two assumed
alternative ancestries. These *genomic clines* are described by two parameters
in every locus, $\alpha$ and $\beta$. The first, determines the position of the
cline and the second, its steepness. To estimate all locus-specific parameters
we use the `bgc` program [@Gompert2012], which requires as inputs:

- The allele counts in both parent populations, in all loci; and
- The allele counts in the admixed population.

Thus, individuals must be classified in advance in three populations: two parental
and at least one admixed. We use previous Admixture results to classify individuals.

## Previous runs

In the `2018-12-15` folder, I run `bgc` with data from the Central Europe contact
zone. But there were too few admixed individuals to properly estimate the cline parameters.
On 2021-04-26, Kristýna run `bgc` with data from the Russian Baltic contact zone, where
about 10 individuals were identified as admixed between *E. roumanicus* and *E. europaeus*
with varying degrees of introgression.

Below I load Kristýna's results for inspection. Unfortunately, I notice an anomaly in
input file `alpha_chain1.txt` to her `plot_chains.R` script. So, I re-produce the files
here first from the `bgc` output in her folder.

```{bash chains}
DATADIR=/data/kristyna/hedgehog/results_2021/2021-04-26
if [ ! -d k ]; then mkdir k; fi
for param in LnL alpha beta; do
   for chain in 1 2; do
      if [ ! -e k/${param}_chain${chain}.txt ]; then
         estpost -i $DATADIR/mcmcout_${chain}.hdf5 \
                 -p $param \
                 -o k/${param}_chain${chain}.txt \
                 -s 2 \
                 -w 0
      fi
   done
done
```

```{r PreviousRun}
library('ggplot2')
library('tidyr')
DATADIR <- '/data/kristyna/hedgehog/results_2021/2021-04-26'

# alpha.1 and alpha.2 will be large matrices with samples from the posterior
# in rows and loci in columns.
alpha.1 <- data.frame(t(as.matrix(read.table('k/alpha_chain1.txt', sep = ','))))
alpha.2 <- data.frame(t(as.matrix(read.table('k/alpha_chain2.txt', sep = ','))))
beta.1  <- data.frame(t(as.matrix(read.table('k/beta_chain1.txt',  sep = ','))))
beta.2  <- data.frame(t(as.matrix(read.table('k/beta_chain2.txt',  sep = ','))))

LnL     <- data.frame(chain1 = t(as.matrix(read.table('k/LnL_chain1.txt', sep = ','))),
                      chain2 = t(as.matrix(read.table('k/LnL_chain2.txt', sep = ','))))
LnL$pos <- 1:(length(LnL$chain1))
LnL.long <- pivot_longer(LnL, cols = c('chain1','chain2'),
                         names_to = 'chain',
                         values_to = 'LnL')

ggplot(data = LnL.long, mapping = aes(x = pos, y = LnL, color = chain)) +
  geom_point()
```

The mixing of log-likelihood values between the two chains suggests that there
is convergence. However, the distribution of alpha and beta values in the posterior
should be compared between chains, rather than only global log-likelihood values.
The problem is that there are $4909 \times 2$ parameters. In order to assess convergence
of all parameter values between the two chains, I should accumulate 4909 images for
alpha parameters and 4909 images for beta parameters and join them in two movies, for easy visualization. Otherwise, I could use a test for comparing distributions and gather the
results for all loci in a vector. Let's use a Kolmogorov-Smirnov test.

```{r tests}
alpha.tests <- mapply(function(x, y) t.test(x, y, alternative = 'two.sided')$p.value,
                      alpha.1, alpha.2)
beta.tests  <- mapply(function(x, y) t.test(x, y, alternative = 'two.sided')$p.value,
                      beta.1, beta.2)

par(mfrow = c(2,2))
   hist(alpha.tests, xlab = 'p-value of convergence', main = 'alpha')
   plot(ecdf(alpha.tests), main = 'alpha')
   abline(a = 0, b = 1, lty = 2, col = 'red')
   hist(beta.tests,  xlab = 'p-value of convergence', main = 'beta')
   plot(ecdf(beta.tests), main = 'beta')
   abline(a = 0, b = 1, lty = 2, col = 'red')
par(mfrow = c(1,1))
```

It seems that both chains converged in the same averages of $\alpha$ and $\beta$
parameters for all 4909 loci.

## Replication

The VCF used in this analysis was a subset of Russian individuals from a complete
VCF filtered before, in `2021-04-13`. The filter is a file called
`popmap_bgc_russia_correct.txt`. Taking the same inputs, I need to reproduce the
HDF5 results, because the `estpost` program complains about the format of the
files produced by Kristyna. I also notice that the input files prepared with a 
python script reduced drastically the number of sites, from 18786 to only 4909.
The reason is that the `vcf2bgc.py` script used then skipped every site with any
missing genotype (`./.`). The consequences of that decision should be evaluated.

I found an alternative `vcf2bgc.py` in [this github repository](https://github.com/btmartin721/file_converters/blob/master/vcf2bgc.py#L199).
I had to change a few things in order to make it produce the estimated error rates
and also process the VCF not produced by ipyrad. I will try now to run `bgc` again
with all 18786 sites obtained with the new `vcf2bgc.py` script.

Unfortunately, the `hdf5` output seem to be corrupted and cannot be either opened
in R (with the `rhdf5` package) or processed with `estpost`. Thus, I will request
the text output.

```{bash replicate}
VCF=/data/kristyna/hedgehog/results_2021/2021-04-26/bgc_RB.recode.vcf
POPMAP=/data/kristyna/hedgehog/results_2021/2021-04-26/popmap_bgc_russia_correct.txt
if [ ! -d all_loci ]; then mkdir all_loci; fi

if [ ! -e bgc_admixedin.txt ]; then
   python vcf2bgc.py -v $VCF \
                     --p1 roumanicus \
                     --p2 europaeus \
                     --admixed admixed \
                     --popmap $POPMAP \
                     --outprefix bgc
fi

if [ ! -e all_loci/chain1_.hdf5 ]; then
   bgc -a bgc_p0in.txt \
       -b bgc_p1in.txt \
       -h bgc_admixedin.txt \
       -F all_loci/chain1_ \
       -O 1 \
       -x 200000 \
       -n  25000 \
       -t     50 \
       -p 1 \
       -q 1 \
       -N 1 \
       -E 1 &> all_loci/chain1.log &
fi

wait 5

if [ ! -e all_loci/chain2_.hdf5 ]; then
   bgc -a bgc_p0in.txt \
       -b bgc_p1in.txt \
       -h bgc_admixedin.txt \
       -F all_loci/chain2_ \
       -O 1 \
       -x 200000 \
       -n  25000 \
       -t     50 \
       -p 1 \
       -q 1 \
       -N 1 \
       -E 1 &> all_loci/chain2.log &
fi
```

## The issue of linkage disequilibrium

```{bash admixed_names}
VCF=/data/kristyna/hedgehog/results_2021/2021-04-26/bgc_RB.recode.vcf
POPMAP=/data/kristyna/hedgehog/results_2021/2021-04-26/popmap_bgc_russia_correct.txt

if [ ! -e admixed_names.txt ]; then
   grep CHROM $VCF | \
   cut -f 1,2,3,4,5,6,7,8,9 --complement --output-delimiter=$'\n' > sample_order.txt
   gawk '(FILENAME ~ /popmap/){
      POP[$1] = $2
   }(FILENAME ~ /sample_order/){
      print $1 "\t" POP[$1]
   }' $POPMAP sample_order.txt > popmap_ordered.txt
   grep admixed popmap_ordered.txt | cut -f 1 > admixed_names.txt
fi
```

```{bash LD}
VCF=/data/kristyna/hedgehog/results_2021/2021-04-26/bgc_RB.recode.vcf
POPMAP=/data/kristyna/hedgehog/results_2021/2021-04-26/popmap_bgc_russia_correct.txt
if [ ! -e admixed.txt ]; then
   grep admixed $POPMAP | cut -f 1 > admixed.txt
fi

if [ ! -e roumanicus.txt ]; then
   grep roumanicus $POPMAP | cut -f 1 > roumanicus.txt
fi

# LD should only be estimated among admixed individuals. For comparison,
# I will also estimate it among E. roumanicus individuals only.
if [ ! -e admixed.geno.ld ]; then
   vcftools --vcf $VCF \
            --keep admixed.txt \
            --maf 0.1 \
            --out admixed \
            --geno-r2 1> r2a.log 2> r2a.err
fi
if [ ! -e roumanicus.geno.ld ]; then
   vcftools --vcf $VCF \
            --keep roumanicus.txt \
            --maf 0.1 \
            --out roumanicus \
            --geno-r2 1>  r2r.log 2> r2r.err
fi
```

I expect linkage disequilibrium to decay with distance. I contrast my expectation
first within the *E. roumanicus* population, to make sure that `vcftools` is producing
reasonable results.

```{r LDrou}
# The .geno.ld files give r^2 values for all pairs of sites within a contig.
LDr <- read.table('roumanicus.geno.ld', header = TRUE)
LDr$Dist <- LDr$POS2 - LDr$POS1

RankPos <- function(x, tot=x){
   stopifnot(all(x %in% tot))
   Index <- rank(unique(tot))
   names(Index) <- unique(tot)
   return(Index[as.character(x)])
}
LDr$ORD1 <- do.call(c, dlply(LDr, 'CHR', .fun = function(x) RankPos(x$POS1, tot = unique(c(x$POS1, x$POS2)))))
LDr$ORD2 <- do.call(c, dlply(LDr, 'CHR', .fun = function(x) RankPos(x$POS2, tot = unique(c(x$POS1, x$POS2)))))

CHRtab <- table(LDr$CHR)
f  <- LDr$CHR %in% names(CHRtab)[CHRtab > 65 & CHRtab < 79] & (! is.na(LDr$R.2))
ggplot(data = LDr, mapping = aes(x = Dist, y = R.2)) + geom_hex() +
   geom_smooth(method='gam', formula=y~log(x)) +
   ylab('Linkage disequilibrium (R^2)') +
   xlab('Distance (bp)')

ggplot(data = LDr[f,], mapping = aes(x = ORD1, y = ORD2, fill = R.2)) +
   geom_tile() + facet_wrap(~CHR)
```

Curiously, despite the admixed population being only 10 individuals (15 roumanicus),
the number of sites that met the requirement of having a MAF of at least 0.1 is
higher (14234) in the admixed than in *E. roumanicus* (2573). The reason is clear:
being admixed, they are heterozygous for many more loci than a parental population.

```{r LDadm}
LDa <- read.table('admixed.geno.ld', header = TRUE)
LDa$DIST <- LDa$POS2 - LDa$POS1

LDa$ORD1 <- do.call(c, dlply(LDa, 'CHR', .fun = function(x) RankPos(x$POS1, tot = unique(c(x$POS1, x$POS2)))))
LDa$ORD2 <- do.call(c, dlply(LDa, 'CHR', .fun = function(x) RankPos(x$POS2, tot = unique(c(x$POS1, x$POS2)))))
CHRtab <- table(LDa$CHR)

# I arbitraryly select a few contigs with the same number of pairs of sites
# for convenient representation.
f  <- LDa$CHR %in% names(CHRtab)[CHRtab == 351] & (! is.na(LDa$R.2))
ggplot(data = LDa, mapping = aes(x = DIST, y = R.2)) + geom_hex() + scale_fill_gradient(trans = 'log')
ggplot(data = LDa[f,], mapping = aes(x = ORD1, y = ORD2, fill = R.2)) +
   geom_tile() + facet_wrap(~CHR)
```

It seems that pairs of SNPs in linkage **equilibrium** among the admixed individuals are
the exception rather than the norm. Surprising as it is, I believe the data is not
an artifact but an indication of really high LD, precisely due to the admixed nature
of the selected individuals: they inherited blocks of alternative ancestrality from
recent ancestors, so that recombination did not have time to break up the associations.

Thus, the recent timing of the admixture events undermine the bgc analysis: if I remove
SNPs in linkage disequilibrium with others, I am likely to retain a very biased representation
of the genetic composition of these individuals. How could we even estimate their genome-wide
index of admixture if we looked only at SNPs in equilibrium?

Let's try, anyways.

## Excluding sites with high R$^2$

```{bash filterVCF}
if [ ! -e highR2.txt ]; then
   gawk '(NR > 1){
      if ($5 > 0.5) {
         print $1 "\t" $3
      }
   }' admixed.geno.ld > highR2.txt
fi

VCF=/data/kristyna/hedgehog/results_2021/2021-04-26/bgc_RB.recode.vcf
if [ ! -e lowR2.recode.vcf ]; then
   vcftools --vcf $VCF \
            --out lowR2 \
            --exclude-positions highR2.txt \
            --recode-INFO-all \
            --recode 2> lowR2.log
fi

POPMAP=/data/kristyna/hedgehog/results_2021/2021-04-26/popmap_bgc_russia_correct.txt
if [ ! -d lowR2 ]; then mkdir lowR2; fi

if [ ! -e lowR2/bgc_admixedin.txt ]; then
   python vcf2bgc.py -v RB_lowR2.recode.vcf \
                     --p1 roumanicus \
                     --p2 europaeus \
                     --admixed admixed \
                     --popmap $POPMAP \
                     --outprefix lowR2/bgc
fi

if [ ! -e lowR2/chain1.hdf5 ]; then
   bgc -a lowR2/bgc_p0in.txt \
       -b lowR2/bgc_p1in.txt \
       -h lowR2/bgc_admixedin.txt \
       -F lowR2/chain1 \
       -O 2 \
       -x 500000 \
       -n  25000 \
       -t     50 \
       -p 1 \
       -q 1 \
       -N 1 \
       -E 1 &> lowR2/chain1.log &
fi

sleep 5

if [ ! -e lowR2/chain2.hdf5 ]; then
   bgc -a lowR2/bgc_p0in.txt \
       -b lowR2/bgc_p1in.txt \
       -h lowR2/bgc_admixedin.txt \
       -F lowR2/chain2 \
       -O 2 \
       -x 500000 \
       -n  25000 \
       -t     50 \
       -p 1 \
       -q 1 \
       -N 1 \
       -E 1 &> lowR2/chain2.log &
fi
```

```{bash extraction}
for param in alpha beta tau-alpha tau-beta; do
   for chain in 1 2; do
      if [ ! -e lowR2/$param.$chain.post.txt ]; then
         estpost -i lowR2/chain$chain.hdf5 \
                 -o lowR2/$param.$chain.post.txt \
                 -p $param \
                 -s 2 > /dev/null
      fi
      if [ ! -e lowR2/$param.$chain.summ.txt ]; then
         estpost -i lowR2/chain$chain.hdf5 \
                 -o lowR2/$param.$chain.summ.txt \
                 -p $param \
                 -s 0 > /dev/null
      fi
   done
done
```

```{r convergence}
alpha.1 <- data.frame(t(as.matrix(read.table('lowR2/alpha.1.post.txt', sep = ',', row.names = 1))))
alpha.2 <- data.frame(t(as.matrix(read.table('lowR2/alpha.2.post.txt', sep = ',', row.names = 1))))
beta.1  <- data.frame(t(as.matrix(read.table('lowR2/beta.1.post.txt',  sep = ',', row.names = 1))))
beta.2  <- data.frame(t(as.matrix(read.table('lowR2/beta.2.post.txt',  sep = ',', row.names = 1))))
tau.1 <- data.frame(
   tau.alpha = t(as.matrix(read.table('lowR2/tau-alpha.1.post.txt', sep = ',', row.names = 1))),
   tau.beta  = t(as.matrix(read.table('lowR2/tau-beta.1.post.txt',  sep = ',', row.names = 1)))
)
tau.2 <- data.frame(
   tau.alpha = t(as.matrix(read.table('lowR2/tau-alpha.2.post.txt', sep = ',', row.names = 1))),
   tau.beta  = t(as.matrix(read.table('lowR2/tau-beta.2.post.txt',  sep = ',', row.names = 1)))
)
```

```{r estimates}
alpha <- read.table('lowR2/alpha.1.summ.txt', sep = ',', header = TRUE)
tau.alpha <- read.table('lowR2/tau-alpha.1.summ.txt', sep=',', header=TRUE)

```

